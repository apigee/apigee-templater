name: tester
uid: test
type: feature
description: Policies to help with unit testing proxies using the API Tester framework at https://tdd.upstr.dev.
categories:
  - testing
parameters:
  - name: UPSTREAM_ID
    displayName: UPSTREAM_ID
    description: Configuration input for UPSTREAM_ID
    default: "{UPSTREAM_ID}"
    examples: []
defaultEndpoint:
  name: default
  basePath: /feature-tester-v1
  routes:
    - name: default
      target: default
  flows:
    - name: PreFlow
      mode: Request
      steps:
        - name: JS-SetTestIds
        - name: SC-GetTestCases
          condition: upstream.testId != null
        - name: JS-SetTestData
          condition: upstream.testId != null
    - name: PostFlow
      mode: Response
      steps:
        - name: JS-RunTest
          condition: upstream.testCase != null
        - name: SC-SaveResults
          condition: upstream.testResults != null
  faultRules: []
  defaultFaultRule:
    name: default-fault
    steps:
      - name: JS-RunTest
        condition: upstream.testCase != null
      - name: SC-SaveResults
        condition: upstream.testResults != null
    alwaysEnforce: "true"
endpoints: []
targets: []
policies:
  - name: JS-RunTest
    type: Javascript
    content:
      Javascript:
        _attributes:
          continueOnError: "false"
          enabled: "true"
          timeLimit: "200"
          name: JS-RunTest
        DisplayName:
          _text: JS-RunTest
        Properties: {}
        ResourceURL:
          _text: jsc://run-test.js
  - name: JS-SetTestData
    type: Javascript
    content:
      Javascript:
        _attributes:
          continueOnError: "false"
          enabled: "true"
          timeLimit: "200"
          name: JS-SetTestData
        DisplayName:
          _text: JS-SetTestData
        Properties: {}
        ResourceURL:
          _text: jsc://set-test.js
  - name: JS-SetTestIds
    type: Javascript
    content:
      Javascript:
        _attributes:
          continueOnError: "false"
          enabled: "true"
          timeLimit: "200"
          name: JS-SetTestIds
        DisplayName:
          _text: JS-SetTestIds
        Properties: {}
        ResourceURL:
          _text: jsc://set-test-id.js
  - name: SC-GetTestCases
    type: ServiceCallout
    content:
      ServiceCallout:
        _attributes:
          continueOnError: "false"
          enabled: "true"
          name: SC-GetTestCases
        DisplayName:
          _text: SC-GetTestCases
        Properties: {}
        Request:
          _attributes:
            clearPayload: "true"
            variable: myRequest
          IgnoreUnresolvedVariables:
            _text: "false"
        Response:
          _text: upstreamResponse
        HTTPTargetConnection:
          Properties: {}
          URL:
            _text: https://tdd.upstr.dev/tests/{upstream.testId}
  - name: SC-SaveResults
    type: ServiceCallout
    content:
      ServiceCallout:
        _attributes:
          continueOnError: "false"
          enabled: "true"
          name: SC-SaveResults
        DisplayName:
          _text: SC-SaveResults
        Properties: {}
        Request:
          _attributes:
            clearPayload: "true"
            variable: myRequest
          IgnoreUnresolvedVariables:
            _text: "false"
          Set:
            Verb:
              _text: POST
            Payload:
              _attributes:
                contentType: application/json
              _text: "

                \        {upstream.testResults}

                \      "
        Response:
          _text: calloutResponse
        HTTPTargetConnection:
          Properties: {}
          URL:
            _text: https://tdd.upstr.dev/tests/{upstream.testId}/results
resources:
  - name: run-test.js
    type: jsc
    content: |
      var upstreamId = context.getVariable("upstream.testId");
      var testCase = context.getVariable("upstream.testCase");

      if (upstreamId && testCase) {
        var testCaseObject = JSON.parse(testCase);
        var responseContent = context.getVariable("response.content");
        print("Running test " + upstreamId + "." + testCaseObject.name);

        var testResults = {
          reportFormat: "CTRF",
          extra: {
            testCase: testCaseObject.name,
            response: responseContent,
            responseHeaders: {}
          },
          results: {
            tool: {
              name: "apigee"
            },
            summary: {
              tests: 0,
              passed: 0,
              failed: 0,
              start: Date.now()
            },
            tests: []
          }
        };

        var headerNames = context.getVariable('response.headers.names');
        var headerCount = context.getVariable('response.headers.count');
        headerNames = headerNames.toArray();

        for (var i = 0; i < headerNames.length; i++) {
          testResults.extra.responseHeaders[headerNames[i]] = context.getVariable('response.header.'+headerNames[i]);
        }

        checkAssertions(testCaseObject, testResults, context, responseContent);

        testResults.results.summary.stop = Date.now();
        // save results
        context.setVariable("upstream.testResults", JSON.stringify(testResults));
        context.setVariable("response.header.x-upstream-results", testResults.results.summary.tests + " tests, " + testResults.results.summary.passed + " passed, " + testResults.results.summary.failed + " failed");
      }

      function checkAssertions(
        testCaseObject,
        testResults,
        context,
        responseContent
      ) {
        for (var i = 0; i < testCaseObject.assertions.length; i++) {
          var assertion = testCaseObject.assertions[i];
          if (assertion.includes("!==")) {
            // doesn't equal strict
            var pieces = assertion.split("!==");
            if (pieces.length === 2) {
              var value = getValue(pieces[0], context, responseContent);
              if (value.trim() !== pieces[1].trim()) {
                testResults.results.summary.tests++;
                testResults.results.summary.passed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "passed",
                  message: "Values matched: " + pieces[1] + "!==" + value,
                  duration: 0,
                });
              } else {
                testResults.results.summary.tests++;
                testResults.results.summary.failed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "failed",
                  message: "Value didn't match: " + pieces[1] + "===" + value,
                  duration: 0,
                });
              }
            }
          } else if (assertion.includes("!=")) {
            // doesn't equal
            var pieces = assertion.split("!=");
            if (pieces.length === 2) {
              var value = getValue(pieces[0], context, responseContent);
              if (value.trim().toLowerCase() != pieces[1].trim().toLowerCase()) {
                testResults.results.summary.tests++;
                testResults.results.summary.passed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "passed",
                  message: "Values matched: " + pieces[1] + "!=" + value,
                  duration: 0,
                });
              } else {
                testResults.results.summary.tests++;
                testResults.results.summary.failed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "failed",
                  message: "Value didn't match: " + pieces[1] + "==" + value,
                  duration: 0,
                });
              }
            }
          } else if (assertion.includes("===")) {
            // exact test
            var pieces = assertion.split("===");
            if (pieces.length === 2) {
              var value = getValue(pieces[0], context, responseContent);
              if (value.trim() === pieces[1].trim()) {
                testResults.results.summary.tests++;
                testResults.results.summary.passed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "passed",
                  message: "Values matched: " + pieces[1] + "===" + value,
                  duration: 0,
                });
              } else {
                testResults.results.summary.tests++;
                testResults.results.summary.failed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "failed",
                  message: "Value didn't match: " + pieces[1] + "!==" + value,
                  duration: 0,
                });
              }
            }
          } else if (assertion.includes("==")) {
            // rough test
            var pieces = assertion.split("==");
            if (pieces.length === 2) {
              var value = getValue(pieces[0], context, responseContent);
              if (value.trim().toLowerCase() == pieces[1].trim().toLowerCase()) {
                testResults.results.summary.tests++;
                testResults.results.summary.passed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "passed",
                  message: "Values matched: " + pieces[1] + "==" + value,
                  duration: 0,
                });
              } else {
                testResults.results.summary.tests++;
                testResults.results.summary.failed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "failed",
                  message: "Value didn't match: " + pieces[1] + "!=" + value,
                  duration: 0,
                });
              }
            }
          } else if (assertion.includes(":")) {
            // contains
            var pieces = assertion.split(":");
            if (pieces.length === 2) {
              var value = getValue(pieces[0], context, responseContent);
              if (value.trim().includes(pieces[1].trim())) {
                testResults.results.summary.tests++;
                testResults.results.summary.passed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "passed",
                  message: "Values matched: " + pieces[1] + ":" + value,
                  duration: 0,
                });
              } else {
                testResults.results.summary.tests++;
                testResults.results.summary.failed++;
                testResults.results.tests.push({
                  name: assertion,
                  status: "failed",
                  message: "Value didn't match: " + pieces[1] + "!:" + value,
                  duration: 0,
                });
              }
            }
          }
        }
      }
      function getValue(name, context, responseContent) {
        var result = "";
        if (name.startsWith("$")) {
          // jsonpath
          var responseContent = context.getVariable("response.content");
          if (responseContent) {
            var responseObject = undefined;
            try {
              responseObject = JSON.parse(responseContent);
            }
            catch(e) {
              print("Exception trying to parse response content.");
            }

            if (responseObject)
              result = jsonPath(responseObject, name, undefined);
          }
        } else {
          result = context.getVariable(name);
        }
        return result.toString();
      }

      function jsonPath(obj, expr, arg) {
      	var P = {
      		resultType: arg && arg.resultType || "VALUE",
      		singleQuoteKeys: arg && arg.singleQuoteKeys || false,
      		escapeUnicode: arg && arg.escapeUnicode || false,
      		result: [],
      		normalize: function(expr) {
      			function fixFilterString(str) {
      				str = str.split('');

      				var mode = {
      					inDoubleQuote: false,
      					inSingleQuote: false,
      					inEscape: false,
      					inRegexp: false,
      					inPath: false,
      					inKeyName: false,
      					inBracket: false,
      				};

      				var lastPathChar
      				var comparatorOp=false
      				var negationCount=0
      				var parenStack=[]

      				for (var i=0; i < str.length; i++) {

      					if (mode.inKeyName && !/[$_A-Za-z0-9.]/.test(str[i])){
      						mode.inKeyName=false
      					}

      					if (mode.inDoubleQuote || mode.inSingleQuote) {
      						if (mode.inEscape) { mode.inEscape = false }
      						else if (str[i] === '"' && mode.inDoubleQuote) { mode.inDoubleQuote = false; }
      						else if (str[i] === "'" && mode.inSingleQuote){ mode.inSingleQuote = false; }
      						else if (str[i] === '\\' ) { mode.inEscape = true }
      					}
      					else if (mode.inRegexp){
      						if (mode.inEscape) { mode.inEscape = false }
      						else if (str[i] === '[') { mode.inBracket=true }
      						else if (str[i] === ']') { mode.inBracket=false	}
      						else if (str[i] === '/' && !mode.inBracket) { mode.inRegexp = false }
      						else if (str[i] === '\\' ) { mode.inEscape = true }
      					}
      					else if(mode.inKeyName){
      						lastPathChar=i
      					}
      					else if (str[i] === '"' || str[i] === "'") {
      						if (str[i] === '"'){ mode.inDoubleQuote = true; }
      						else { mode.inSingleQuote = true; }
      						lastPathChar = i
      					}
      					else if (str[i] === '$' || str[i] === '@') {
      						lastPathChar = i

      						if (str[i+1] === '.') {
      							mode.inKeyName=true
      							lastPathChar=i
      						}
      					}
      					else if (str[i] === ']') {
      						lastPathChar=i
      						mode.inBracket=false
      						if (str[i+1] === "."){
      							mode.inKeyName=true
      							i++
      						}
      					}
      					else if (str[i] === '/' ) {
      						mode.inRegexp = true
      					}
      					else if ((str[i] === '=' || str[i] === '!' || str[i] === '<' || str[i] === '>' || str[i] === '=' ) && str[i+1] === '=' ) {
      						lastPathChar=undefined
      						i=i+1
      						mode.inPath=false
      						comparatorOp=true
      					}
      					else if (str[i] === '<' || str[i] === '>') {
      						lastPathChar=undefined
      						mode.inPath=false
      						comparatorOp=true
      					}
      					else if (str[i] === '=' && str[i+1] === '~' ) {
      						lastPathChar=undefined
      						mode.inPath=false
      						comparatorOp=true

      						i=i+1
      					}
      					else if ((str[i] === '&' && str[i+1] === '&') || (str[i] === '|' && str[i+1] === '|' )) {
      						if (comparatorOp != true && lastPathChar !== undefined) {
      							str.splice((lastPathChar+1),0,"!==undefined")
      							i++
      						}
      						mode.inPath=false
      						comparatorOp=false

      						if(negationCount){
      							for (var loop=0; loop<negationCount; negationCount--){
      								str.splice(i,0,")")
      								i++
      							}
      						}
      					}
      					else if(str[i] === '!'){
      						str.splice(i+1,0,"(")
      						negationCount++
      						i++
      					}
      					else if(str[i] === '('){
      						parenStack.unshift(negationCount)
      						negationCount=0
      					}
      					else if(str[i] === ')'){
      						if(negationCount){
      							for (var loop=0; loop<negationCount; negationCount--){
      								str.splice(i+1,0,")")
      								i++
      							}
      						}
      						negationCount=parenStack.shift()
      					}

      					if(i == (str.length-2)){
      						if(comparatorOp != true && lastPathChar !== undefined) {
      							str.splice((lastPathChar+1),0,"!==undefined")
      							i++
      						}
      						if(negationCount){
      							for (var loop=0; loop<negationCount; negationCount--){
      								str.splice(i+1,0,")")
      								i++
      							}
      						}
      					}
      				}
      				var finalString = str.join('')
      				return finalString
      			}			//work on strings only, pass through all others (like a pre-objectified path array)
      			if (expr.constructor === null || expr.constructor !== String) { return expr }

      			var pathStack=[]
      			var baldRecursion=false
      			var lastLastIndex=0;

      			var revExpr=expr.replace(/^\s*/,"").replace(/\s*$/,"").split('').reverse().join('')

      			var Level1Regex = /([\w\d$]*[A-Za-z_$])(\.{1,2})|(\*?)(\.{1,2})|(\])|(\$)/g

      			do {
      				var L1Match = Level1Regex.exec(revExpr);
      				if(L1Match === null) { break }

      				if((lastLastIndex+L1Match[0].length) !== Level1Regex.lastIndex || L1Match[0] === "" ){
      					throw new SyntaxError("Malformed path expression: " + expr)
      				}

      				if(L1Match[1] || L1Match[3]) {
      					if(baldRecursion){throw new SyntaxError("Additional operators (./..) disallowed after recursive descent: " + expr)}
      					L1Match=L1Match.filter(function(p) { return p != null })

      					if(L1Match[1] === '*') { pathStack.unshift({"expression":"*"}) }
      					else if(L1Match[1]) { pathStack.unshift(L1Match[1].split('').reverse().join('')) }

      					if (L1Match[2] === '..') { pathStack.unshift({"expression":".."}) }
      					else if(L1Match[1] === '') { Level1Regex.lastIndex=lastLastIndex;  break }
      				}
      				else if(L1Match[4]) {
      					if(L1Match[4] === '.'){ break }
      					else if(!pathStack.length){ baldRecursion=true; break }
      					else if (pathStack[0].expression === "..") {
      						throw new SyntaxError("Additional operators (./..) disallowed after recursive descent: " + expr)
      					}
      					pathStack.unshift({"expression":".."})
      				}
      				else if(L1Match[5]) {
      					baldRecursion = false

      					var Level2Regex=/\s*(["'])(.*?)\1(?!\\)|(\*(?!:\*))|(\d+\-?)|(-)|(,)|(:)|(\))|(\[)|\s/g
      					var subArray=[], L2Match=[], subLastLastIndex=Level1Regex.lastIndex, pendingData=[], intraSlice=false, needsDelimiter=false, isSlice=false;
      					var openBracket=0, closedBracket=1;

      					Level2Regex.lastIndex = Level1Regex.lastIndex
      					do {
      						L2Match=Level2Regex.exec(revExpr)
      						if (L2Match === null || subLastLastIndex === Level2Regex.lastIndex || subLastLastIndex + L2Match[0].length !== Level2Regex.lastIndex ) {
      							throw new SyntaxError("Malformed path expression : " + expr)
      						}

      						L2Match = L2Match.map(function(s){return (!s ? s : s.split('').reverse().join(''))})

      						if(L2Match[2] === ''){ subArray.unshift(L2Match[2]) }
      						else if(L2Match[2]){
      							if (needsDelimiter) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
      							if (intraSlice) { break }
      							pendingData.unshift(JSON.parse('"'+(L2Match[1] === "'" ? L2Match[2].replace(/\\'/g,"'").replace(/\"/g,"\\\"") : L2Match[2])+'"',null,0))
      						}
      						else if(L2Match[3]){
      							if (needsDelimiter) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
      							if (intraSlice) { break }
      							else { pendingData.unshift({"expression":"*"}) }
      						}
      						else if(L2Match[4]){
      							if (needsDelimiter && !isSlice) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
      							if (isSlice && intraSlice) { intraSlice=false }

      							if (L2Match[4] !== "0" && (L2Match[4][0] === "0" || (L2Match[4][0] === "-" && L2Match[4][1] === "0"))){
      								throw new Error("Octal indices are disallowed: " + L2Match[4])
      							}
      							else{
      								pendingData.unshift(Number(L2Match[4]))
      							}
      						}
      						else if(L2Match[5]){
      							if (needsDelimiter) { Level2Regex.lastIndex=subLastLastIndex; break; } else { needsDelimiter=true }
      							pendingData.unshift({"expression":"-"})
      						}
      						else if(L2Match[6]){

      							if (pendingData.length && !isSlice){
      								subArray.unshift(pendingData[0])
      							}
      							else if (pendingData.length){
      								if(isSlice && intraSlice){ pendingData.unshift(null) }
      								subArray.unshift({"expression":pendingData})
      							}

      							pendingData=[], needsDelimiter=false
      							if (isSlice) { intraSlice=false; isSlice=false }
      						}
      						else if(L2Match[7]){
      							isSlice=true

      							if (pendingData.length === 1 && pendingData[0] !== null && (pendingData[0].constructor === String || !(pendingData[0].constructor === Number || pendingData[0].expression[0] === "(" ))){
      								break
      							}

      							if(!pendingData.length || intraSlice) { pendingData.unshift(null) }

      							if (!intraSlice) { intraSlice=true }
      						}

      						else if(L2Match[8]){
      							var openParens=0, closeParens=1, L3Match=[]

      							var filterText=L2Match[8]

      							var Level3Regex=/(["'])(.*?)\1(?!\\)|(\()|(\))|(\/.*?\/(?!\\)\s*~=)|(~=\s*\/.*?\/(?!\\))|(==?((?:=|!)))|(.)/g

      							if (isSlice) { intraSlice = false }
      							else if (needsDelimiter) { break }

      							Level3Regex.lastIndex = Level2Regex.lastIndex
      							do {
      								L3Match = Level3Regex.exec(revExpr)

      								if(L3Match[1]) {
      									filterText+=L3Match[0].replace(/@/g, "@\\")
      								}
      								else if(L3Match[3]) {
      									filterText+=L3Match[3]
      									openParens += 1
      								}
      								else if(L3Match[4]) {
      									filterText+=L3Match[4]
      									closeParens += 1
      								}
      								else if(L3Match[5]||L3Match[6]) {
      									filterText+=L3Match[0].replace(/@/g, "@\\")
      								}
      								else if(L3Match[7]) {
      									filterText+="==" + L3Match[8]
      								}
      								else if(L3Match[9]) {
      									if(L3Match[9] === "=" && !/[<>!]/.test(revExpr[Level3Regex.lastIndex])) {
      										break
      									}
      									filterText+=L3Match[9]
      								}

      								if (closeParens === openParens){
      									needsDelimiter=true

      									if(revExpr[Level3Regex.lastIndex] === '?'){
      										if(isSlice){
      											Level3Regex.lastIndex=0
      											break
      										}
      										filterText+="?"
      										Level3Regex.lastIndex = Level3Regex.lastIndex+1
      									}

      									Level2Regex.lastIndex = Level3Regex.lastIndex
      									var filterTextFinal = fixFilterString(filterText.split('').reverse().join(''))
      									pendingData.unshift({"expression":filterTextFinal})
      									break;
      								}
      							} while (Level3Regex.lastIndex !== 0 && Level3Regex.lastIndex !== revExpr.length)

      							if (closeParens !== openParens) { break }
      						}

      						else if(L2Match[9]){

      							if(Level2Regex.lastIndex - Level1Regex.lastIndex === 1) {
      								break
      							}
      							else {
      								Level1Regex.lastIndex = Level2Regex.lastIndex
      								break
      							}
      						}

      						subLastLastIndex=Level2Regex.lastIndex
      					} while(Level2Regex.lastIndex !== 0 && Level2Regex.lastIndex !== revExpr.length )

      					if(pendingData.length === 1 && !isSlice) { subArray.unshift(pendingData[0]) }
      					else if (pendingData.length){
      						if(isSlice && intraSlice){ pendingData.unshift(null) }
      						if(pendingData[2] === undefined){ pendingData[2] = null }
      						subArray.unshift({"expression":pendingData})
      					}

      					if(subArray.length > 1){ pathStack.unshift(subArray) }
      					else { pathStack.unshift(subArray[0]) }
      				}
      				else if(L1Match[6]){
      					if(Level1Regex.lastIndex === revExpr.length){ var hasRoot=true }
      					else { break }
      				}
      				lastLastIndex=Level1Regex.lastIndex
      			} while(Level1Regex.lastIndex !== 0 && Level1Regex.lastIndex !== revExpr.length )

      			if (!hasRoot || baldRecursion || Level1Regex.lastIndex !== revExpr.length) { throw new SyntaxError("Malformed path expression: " + expr) }

      			return pathStack
      		},
      		asPath: function(path) {
      			if(P.resultType === "PATH_OBJECT"){ return {"path":path} }

      			var qt = P.singleQuoteKeys ? "'" : '"';
      			var p=(P.resultType === "PATH_JSONPOINTER" ? "" : "$");
      			var x = path.slice()

      			for (var i=0,n=x.length; i<n; i++){

      				if(P.resultType === "PATH_JSONPOINTER") {
      					p += "/" + (x[i].constructor === Number ? x[i] : x[i].replace(/~/g,"~0").replace(/\//g,"~1"))
      				}
      				else {
      					p += x[i].constructor === Number ? "["+x[i]+"]" : (P.resultType === "PATH_DOTTED" && /^[A-Za-z_$][\w\d$]*$/.test(x[i]) ? "." + x[i] : ("["+ qt + x[i].replace((P.escapeUnicode ? /[\u0000-\u001f\u007f-\uffff|\\|"|']/g : /[\u0000-\u001f\u007f|\\|"|']/g), function(chr) { switch(chr) { case '\b': return "\\b"; case '\f': return "\\f"; case '\n': return "\\n"; case '\r': return "\\r"; case '\t': return "\\t";case '\\': return "\\\\";case '"': return (P.singleQuoteKeys ? "\"" : "\\\"" );case '\'': return (P.singleQuoteKeys ? "\\'" : "'" );default: return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4);}}) + qt + "]"));
      				}
      			}
      			return p;
      		},
      		store: function(p, v) {
      			if (P.escapeUnicode && v !== null && v.constructor === String){
      				v = v.replace(/[\u007F-\uFFFF]/g, function(chr) { return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4) })
      			}

      			if (p) { P.result[P.result.length] = /^PATH/.test(P.resultType) ? P.asPath(p) : v }
      			return !!p;
      		},
      		trace: function(expr, val, path) {

      			if(expr === false) return expr

      			if (expr.length) {

      				var x = expr.slice()
      				var loc = x.shift();


      				if(val !== null && Array.isArray(val) && loc.constructor === String && loc.match(/^0/) && loc !== "0"){
      					throw new Error("Property name '"+ loc +"' is a string with leading zeros and target is an array!")
      				}

      				if(loc.constructor === Number && Math.sign(loc) === -1 && (val instanceof Array || val.constructor === String)) {
      					loc = (val.length+loc)
      				}

      				if(Array.isArray(loc)){
      					for (var i=0; i<loc.length; i++) {
      						var tx = x.slice()
      						tx.unshift(loc[i])
      						P.trace(tx, val, path)
      					}
      				}
      				else if(loc.constructor === Object) {
      					if(Array.isArray(loc.expression)){
      						P.slice(loc.expression, x, val, path);
      					}
      					else if (loc.expression === "*") {
      						P.walk(loc.expression, x, val, path, function(m,l,x,v,p) { var tx = x.slice(); tx.unshift(m); P.trace(tx,v,p); });
      					}
      					else if (loc.expression === "..") {
      						P.trace(x, val, path);
      						P.walk(loc, x, val, path, function(m,l,x,v,p) { var tx = x.slice(); tx.unshift({"expression":".."}); var tp = p.slice(); tp.push(m); typeof v[m] === "object" && P.trace(tx,v[m],tp); });
      					}
      					else if (/^\(.*?\)$/.test(loc.expression))
      					{
      						var tx = x.slice();
      						tx.unshift(P.eval(loc.expression, val, path[path.length-1]))
      						P.trace(tx, val, path);
      					}
      					else if (/^-$/.test(loc.expression))
      					{
      						if(val !== null && Array.isArray(val)) {
      							var tx = x.slice();
      							tx.unshift(P.eval("(@.length)", val, path[path.length-1]))
      							P.trace(tx, val, path);
      						}
      					}
      					else if (/^\?/.test(loc.expression)){
      						P.walk(loc.expression, x, val, path, function(m,l,x,v,p) {
      							if (P.eval(l.replace(/^\?/,""), v instanceof Array ? v[m] : v, m)) {
      								var tx = x.slice(); tx.unshift(m); P.trace(tx,v,p);
      							}
      						});
      					}
      				}
      				else if (val && val.constructor !== String && val[loc] !== undefined && typeof val[loc] !== "function") {
      					var tpath = path.slice()
      					tpath.push(Array.isArray(val) ? Number(loc) : loc)
      					P.trace(x, val[loc], tpath);
      				}
      			}
      			else {
      				P.store(path, val);
      			}
      		},
      		walk: function(loc, expr, val, path, f) {
      			if (val instanceof Array) {
      				for (var i=0,n=val.length; i<n; i++) {
      					if (i in val) {
      						f(i,loc,expr,val,path);
      					}
      				}
      			}
      			else if (typeof val === "object") {
      				for (var m in val) {
      					if (val.hasOwnProperty(m)) {
       						f(m,loc,expr,val,path);
      					}
      				}
      			}
      		},
      		slice: function(loc, expr, val, path) {
      			if (val instanceof Array) {
      				var str="", len, start, end, step=1;
      				loc[0]=loc[0] !== undefined ? loc[0] : null; loc[1]=loc[1] !== undefined ? loc[1] : null; loc[2]=loc[2] !== undefined ? loc[2] : null

      				if ((loc[2] === null || loc[2].constructor === Number ? loc[2] : P.eval(loc[2].expression,val,path[path.length-1])) === 0) {
      					throw new RangeError("Slice step cannot be zero: [" + loc.join(":") + "]")
      				}
      				else {
      					step=parseInt((loc[2] === null || loc[2].constructor === Number ? loc[2] : P.eval(loc[2].expression,val,path[path.length-1]))||step)
      				}

      				if(Math.sign(step) === -1){
      					len=val.length, start=len-1, end=(len+(loc[1] === null ? 1 : 0))*(-1)
      				}
      				else {
      					len=val.length, start=0, end=len
      				}

      				start = parseInt((loc[0] === null || loc[0].constructor === Number ? loc[0] : P.eval(loc[0].expression,val,path[path.length-1]))||((loc[0] === null || loc[0].constructor === Number ? loc[0] : P.eval(loc[0].expression,val,path[path.length-1])) === 0 ? 0 : start));
      				end = (loc[1] === 0) ? 0 : parseInt((loc[1] === null || loc[1].constructor === Number ? loc[1] : P.eval(loc[1].expression,val,path[path.length-1]))||end)

      				start = (start < 0) ? Math.max(Math.sign(step) === -1 ? -1 : 0,start+len) : Math.min(len,start);
      				end = (end < 0) ? Math.max(Math.sign(step) === -1 ? -1 : 0,end+len) : Math.min(len,end);

      				if(Math.sign(step) === -1){ var op=">" } else { var op="<" }

      				for (var i=start; eval(i+op+end); i+=step){
      					var texpr = expr.slice()
      					texpr.unshift(i)
      					P.trace(texpr, val, path);
      				}
          		}
      		},
      		eval: function(x, _v, _vname) {

      			var tx = x.slice()

      			var forbiddenInvocations=tx.split('').reverse().join('')
      				.replace(/(["'])(.*?)\1(?!\\)/g, "")
      				.replace(/(\/.*?\/(?!\\)\s*~=)|(=~*\s\/.*?\/(?!\\))/g, "")
      				.replace(/\(\s*/g,"(").replace(/([;\.\+\-~\!\*\/\%\>\<\&\^\|\:\?\,])/g, " ")
      				.replace(/\s+/g," ")
      				.split('').reverse().join('').split(' ')
      				.filter(function(f){return (/\(/).test(f)})
      				.filter(function(f){return (/[!^]\(|[\w\d_$]\(/).test(f)})
      				.filter(function(f){return !((/test\(|exec\(|match\(/).test(f))})

      			if(forbiddenInvocations.length){ throw new Error("Invocation violation: " + forbiddenInvocations) };

      			try {
      				var evalResult = eval(x.replace(/(^|[^\\])@/g, "$1_v")
      					.replace(/\\@/g, "@")
      					.replace(/(_v(?:(?!(\|\||&&)).)*)=~((?:(?!\)* *(\|\||&&)).)*)/g,
      						function(match, p1, p2, p3, offset, currentString) {
      							return match ? p3.trim()+'.test('+p1.trim()+')' : match
      						}
      					)
      					.replace(/((?:(?!\)* *(\|\||&&)).)*)\s+=~\s+(_v(?:(?!(\|\||&&)).)*)/g,
      						function(match, p1, p2, p3, offset, currentString) {
      							return match ? p1.trim()+'.test('+p3.trim()+')' : match
      						}
      					)
      				);
      				return evalResult
      			}
      			catch(e) {
      				throw new SyntaxError("eval: " + e.message + ": " + x.replace(/(^|[^\\])@/g, "$1_v")
      					.replace(/\\@/g, "@") /* issue 7 : resolved .. */
      					/* 2020/01/09 - manage regexp syntax "=~" */
      					.replace(/(_v(?:(?!(\|\||&&)).)*)=~((?:(?!\)* *(\|\||&&)).)*)/g,
      						function(match, p1, p2, p3, offset, currentString) {
      							return match ? p3.trim()+'.test('+p1.trim()+')' : match
      						}
      					)
      					.replace(/((?:(?!\)* *(\|\||&&)).)*)\s+=~\s+(_v(?:(?!(\|\||&&)).)*)/g,
      						function(match, p1, p2, p3, offset, currentString) {
      							return match ? p3.trim()+'.test('+p1.trim()+')' : match
      						}
      					)
      				)
      			}
      		}
      	};

      	var $ = obj;

      	if (expr && obj !== undefined && (P.resultType == "VALUE" || /^PATH/.test(P.resultType))) {
      		P.trace(P.normalize(expr), obj, []);

      		return P.result.length ? P.result : [];
      	}
      }
  - name: set-test-id.js
    type: jsc
    content: |-
      var upstreamId = context.getVariable("request.header.x-upstream-id");
      if (!upstreamId) {
        // try from properties
        upstreamId = context.getVariable("propertyset.tester.UPSTREAM_ID")
      }
      if (upstreamId && upstreamId.includes(".")) {
        var pieces = upstreamId.split(".");
        context.setVariable("upstream.testId", pieces[0]);
        context.setVariable("upstream.testCaseId", pieces[1]);
      } else {
        context.setVariable("upstream.testId", upstreamId);
      }
  - name: set-test.js
    type: jsc
    content: |
      var upstreamId = context.getVariable("upstream.testId");
      var testCaseId = context.getVariable("upstream.testCaseId");
      var testContent = context.getVariable("upstreamResponse.content");
      var proxyUrl = context.getVariable("proxy.url");
      var pathSuffix = context.getVariable("proxy.pathsuffix");
      var requestVerb = context.getVariable("request.verb");

      if (upstreamId && testContent) {
        var testCases = JSON.parse(testContent);
        if (testCases) {
          var testCase = findTest(testCaseId, testCases, proxyUrl, pathSuffix, requestVerb, request.content);
          if (testCase) {
            context.setVariable("upstream.testCase", JSON.stringify(testCase));
            // request
            if (testCase.body)
              context.setVariable("request.content", testCase.body);

            // variables
            if (testCase.variables) {
              // set variables
              for (var i=0; i<testCase["variables"].length; i++) {
                var variable = testCase["variables"][i];
                var equalsIndex = variable.indexOf("=");
                var variableName = variable.substring(0, equalsIndex);
                print("Found variable name: " + variableName);
                var value = variable.substring(equalsIndex + 1);
                print("Found value: " + value);
                context.setVariable(variableName, value);
              }
            }
          }
        }
      }

      function findTest(testId, testCases, proxyUrl, requestPath, requestVerb, requestContent) {
        print("Finding test with requestPath: " + requestPath + " and requestVerb " + requestVerb);
        var result = undefined;

        if (testCases && testCases.tests && testCases.tests.length > 0) {
          var filteredArray = testCases.tests.filter((x) => x.name == testId);
          if (filteredArray.length > 0) {
            print("Found test case using name: " + testId);
            result = filteredArray[0];
          }
          else {
            filteredArray = testCases.tests.filter((x) => (proxyUrl.startsWith(x.url) && (x.method == requestVerb)));
            if (filteredArray.length > 0) {
              print("Found test case using url: " + proxyUrl);
              result = filteredArray[0];
            } else {
              filteredArray = testCases.tests.filter((x) => (x.method == requestVerb && x.path == requestPath));
              if (filteredArray.length > 0) {
                print("Found test case using path and verb: " + requestVerb + " - " + requestPath);
                result = filteredArray[0];
              }
              else if (testCases.tests.length > 0) {
                print("Did not find test case, taking first one.");
                result = testCases.tests[0];
              }
            }
          }
        }

        return result;
      }
  - name: tester.properties
    type: properties
    content: |
      UPSTREAM_ID={UPSTREAM_ID}
tests: []
